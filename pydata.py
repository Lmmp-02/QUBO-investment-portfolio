# -*- coding: utf-8 -*-
"""PyData.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LDry9BbL_3MpFP3c6J3XhP1zJwDntKZu
"""

!pip install -q yfinance qiskit==0.45.0 qiskit-finance==0.4.0 qiskit-optimization==0.6.0

import yfinance as yf
import numpy as np
import pandas as pd

from qiskit_finance.applications.optimization import PortfolioOptimization
from qiskit_optimization.algorithms import MinimumEigenOptimizer
from qiskit.algorithms import NumPyMinimumEigensolver

# === Paso 1: Descargar precios ===
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META',
           'JNJ', 'V', 'JPM', 'TSLA', 'NVDA']

data = yf.download(tickers, period="1mo", interval="1d")
df_close = data['Close'].dropna()

# === Paso 2: Calcular retornos ===
log_returns = np.log(df_close / df_close.shift(1)).dropna()
mean_returns = log_returns.mean().values
cov_matrix = log_returns.cov().values

# === Paso 3: Crear problema de optimizaciÃ³n ===
budget = 4
risk_factor = 0.5

portfolio = PortfolioOptimization(expected_returns=mean_returns,
                                  covariances=cov_matrix,
                                  risk_factor=risk_factor,
                                  budget=budget)

qp = portfolio.to_quadratic_program()
print("ðŸ“‹ Problema de optimizaciÃ³n:")
print(qp.prettyprint())

# === Paso 4: Resolver con NumPyMinimumEigensolver (clÃ¡sico) ===
exact_solver = NumPyMinimumEigensolver()
optimizer = MinimumEigenOptimizer(exact_solver)

result = optimizer.solve(qp)

# === Paso 5: Mostrar activos seleccionados ===
print("\nâœ… Resultado (cartera seleccionada):")
for i, selected in enumerate(result.x):
    if selected:
        print(f"- {tickers[i]}")

import yfinance as yf
import numpy as np
import pandas as pd

from qiskit_optimization import QuadraticProgram
from qiskit_optimization.algorithms import GroverOptimizer
from qiskit.utils import algorithm_globals
from qiskit_aer.primitives import Sampler

# Seleccionar tickers
tickers = ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'META',
           'JNJ', 'V', 'JPM', 'TSLA', 'NVDA']

# Descargar precios del Ãºltimo mes (20 dÃ­as hÃ¡biles)
data = yf.download(tickers, period="3mo", interval="1d", auto_adjust=False)['Close']
df_close = data.dropna()

df_close.head()

# Retornos logarÃ­tmicos diarios
log_returns = np.log(df_close / df_close.shift(1)).dropna()

# Media de retornos y matriz de covarianza
mean_returns = log_returns.mean().values
cov_matrix = log_returns.cov().values

print("\nRetornos medios diarios estimados:")
print(mean_returns.round(4))

# ParÃ¡metros del problema
n_assets = len(tickers)
budget = 4  # nÃºmero mÃ¡ximo de activos a seleccionar
risk_factor = 0.5  # Î»: tradeoff entre retorno y riesgo

# === 4. Crear problema QUBO manualmente ===
qp = QuadraticProgram()
for i in range(n_assets):
    qp.binary_var(name=f'x{i}')  # x_i âˆˆ {0, 1}

# FunciÃ³n objetivo
linear = (-mean_returns + risk_factor * np.sum(cov_matrix, axis=1)).tolist()
quadratic = (risk_factor * cov_matrix).tolist()

qp.minimize(linear=linear, quadratic=quadratic)
qp.linear_constraint({f'x{i}': 1 for i in range(n_assets)}, sense='==', rhs=budget, name='budget')

print("\nProblema QUBO formulado en Qiskit:")
print(qp.prettyprint())

# === 4. Resolver con GroverOptimizer ===
algorithm_globals.random_seed = 42
sampler = Sampler()  # Aer Sampler (backend cuÃ¡ntico simulado)
optimizer = GroverOptimizer(num_value_qubits=3, num_iterations=5, sampler=sampler)

result = optimizer.solve(qp)

selected_indices = [i for i, x in enumerate(result.x) if x == 1]
selected_assets = [tickers[i] for i in selected_indices]

returns_selected = mean_returns[selected_indices]
cov_selected = cov_matrix[np.ix_(selected_indices, selected_indices)]

# Retorno esperado total (media si los pesos son iguales)
expected_return_total = returns_selected.mean()
risk_total = (1 / budget**2) * cov_selected.sum()

# Mostrar activos seleccionados
print("\nâœ… Activos seleccionados en la cartera Ã³ptima:")
for asset in selected_assets:
    print(f"â€¢ {asset}")

summary_df = pd.DataFrame({
    'Empresa': selected_assets,
    'Retorno diario estimado': np.round(returns_selected, 5)
})
summary_df['Peso (%)'] = (100 / budget)

print("\nðŸ“‹ Tabla de activos seleccionados:")
print(summary_df.to_string(index=False))

print("\nðŸ“ˆ MÃ©tricas agregadas de la cartera:")
print(f"- Retorno esperado total (media): {expected_return_total:.4f}")
print(f"- Riesgo total (varianza combinada): {risk_total:.4f}")